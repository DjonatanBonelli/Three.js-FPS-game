<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Para garantir que o cursor não apareça ao rolar a página */
        }
        canvas {
            display: block;
        }
        /* Oculta o cursor quando dentro do canvas */
        canvas:hover {
           /* cursor: none; */
        }
        .mira {
            height: 3px;
            width: 3px;
            background-color: green;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            font-family: Arial, Helvetica, sans-serif;
            color: red;
            display: none;
            z-index: 10;
            pointer-events: none; 
        }

        .menu{
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
        }
        .killLog{
            position: fixed;
            right: 1%;
            top: 5%;
            font-size: 30px;
            color: white;
            background-color: red;
            padding: 10px;
            width: 150px;
            display: none;
        }
        .killLogFrame{
            position: fixed;
            right: 0%;
            top: 5%;
            width: 200px;
            height: 400px;
        }

        .recarga{
            position: fixed;
            bottom: 5%;
            right: 5%;
            font-size: 50px;
            font-family: Arial, Helvetica, sans-serif;
        }

                
    </style>
    <title>Battle Shoot</title>
</head>
<body>
    <div class="menu" id="menu">Continuar (C)</div>
    <div class="mira" id="mira"></div>
    <div class="crosshair" id="crosshair">X</div>
    <div class="killLogFrame" id="killLogFrame"></div>
    <span class="recarga" id="recarga"></span>

    <script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js",
                "three/addons/": "https://threejs.org/examples/jsm/"
            }
        }
    </script>
    <script src="threex.keyboardstate.js"></script>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
  //      const controls = new OrbitControls(camera, renderer.domElement);
        
        const materialPhysical = new THREE.MeshPhysicalMaterial({
        color: 0x00ff00,        // Cor básica
        roughness: 0.5,         // Rugosidade da superfície (0 é liso, 1 é completamente rugoso)
        metalness: 0.5,         // Metalicidade da superfície (0 é não metálico, 1 é completamente metálico)
        clearcoat: 0.5,         // Cobertura clara (0 a 1)
        clearcoatRoughness: 0,// Rugosidade da cobertura clara (0 a 1)
        reflectivity: 0.5,      // Refletividade da superfície (0 a 1)
        transmission: 0,      // Transmissão de luz (0 a 1, 0 é opaco, 1 é completamente transparente)
        thickness: 0,         // Espessura do material para transmissão
        ior: 0,               // Índice de refração (1.0 para ar, valores maiores para materiais como vidro, água, etc.)
        sheen: 0,             // Intensidade do brilho (0 a 1)
        sheenColor: 0xff0000    // Cor do brilho
        });


        ///////////////// TEXTURAS /////////////// 

        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load('textchaomadeira.jpg');
        // Carrega a textura de equirectangular
        const textureLoader2 = new THREE.TextureLoader();
        const texture2 = textureLoader.load('textceu.jpg');
        // Configura a textura para repetir na direção Y (para o céu)
        texture2.wrapS = THREE.RepeatWrapping;
        texture2.repeat.y = 2; // Ajuste conforme necessário para obter o resultado desejado
        // Cria uma geometria esférica
        const geometry = new THREE.SphereGeometry(500, 60, 40);
        // Inverte as normais para o interior da esfera
        geometry.scale(-1, 1, 1);
        // Aplica a textura à esfera
        const material2 = new THREE.MeshBasicMaterial({ map: texture2 });
        const sphere = new THREE.Mesh(geometry, material2);
        // Adiciona a esfera à cena
        scene.add(sphere);
        // Crie um material com a textura
        const material = new THREE.MeshBasicMaterial({ map: texture }); // Use MeshBasicMaterial para uma textura sem iluminação

        ///////////////// TEXTURAS /////////////// 

        const plano = new THREE.PlaneGeometry( 1000, 1000, 100, 100 );
        const corpo = new THREE.BoxGeometry( 50, 0.8, 2 );

        const chao = new THREE.Mesh( plano, material );
        const cubo = new THREE.Mesh( corpo, materialPhysical );
        cubo.position.set(0, 1, -3)

            /*
        const models = [
            { url: 'carro.glb', position: { x: 0, y: 0, z: 0 }, scale: 1 },
            { url: 'casa.glb', position: { x: 5, y: 0, z: 0 }, scale: 1 },
            { url: 'espada.glb', position: { x: -5, y: 0, z: 0 }, scale: 1 }
        ];

        const loader = new GLTFLoader();
        models.forEach(model => {
            loader.load(model.url, gltf => {
                const object = gltf.scene;
                object.position.set(model.position.x, model.position.y, model.position.z);
                object.scale.set(model.scale, model.scale, model.scale);
                scene.add(object);
            }, undefined, error => {
                console.error('An error happened', error);
            });
        });
            */
        
        // Luz ambiente
        const ambientLight = new THREE.AmbientLight(0x404040, 20);
        scene.add(ambientLight);
        
        // Luz direcional
        const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
        directionalLight.position.set(10, 10, 10);
        //scene.add(directionalLight);

        scene.add(cubo)
    
        const mira = document.getElementById("mira");

        class Personagem {
            constructor(geometry, material, vidaInicial){
                this.mesh = new THREE.Mesh(geometry, material);
                this.vida = vidaInicial;
                scene.add(this.mesh);
            }

            tomaDano(qtdDano){
                this.vida -= qtdDano;
                mira.style.width = "2px";
                if (this.vida <= 0){
                    this.morre();
                }
            }

            morre() {
                scene.remove(this.mesh);
                count++;
                criaKillLog(count);
                
                const kill_log = document.getElementById('killLog' + count);
                const tempo = 2000;
                setKillLog(kill_log, tempo);
            }
        }

        let inimigos = [];

        function criaInimigo(x, y, z) {

            const geometry = new THREE.BoxGeometry(1, 1.5, 1);
            const material = new THREE.MeshNormalMaterial();

            const inimigo = new Personagem(geometry, material, 100);

            inimigo.mesh.position.set(x, y, z);

            inimigos.push(inimigo);
        }

        function geraInimigos(numInimigos) {

            for (let i = 0; i < numInimigos; i++) {
                // Gere posições aleatórias para os inimigos
                const dists = [-12, -18, -24]
                const dist_sel = Math.floor(Math.random() * 3); 
                const x = Math.random() * 10 - 5;
                const y = 1.5; 
                const z = dists[dist_sel];

                criaInimigo(x, y, z);
            }
        }
        function showCrosshair() {
            crosshair.style.display = 'block';
            crosshair.style.opacity = 1;
            setTimeout(() => {
                crosshair.style.transition = 'opacity 0.1s';
                crosshair.style.opacity = 0;
                setTimeout(() => {
                    crosshair.style.display = 'none';
                    crosshair.style.transition = ''; // Reset transition for next use
                }, 20);
            }, 20); // Duration the "X" stays visible
        }

        let municao = 15;
        document.getElementById('recarga').textContent = municao;

        function atira() {
            if(municao >= 1){
                document.getElementById('recarga').textContent = municao-1;
                // Calculate mouse position in normalized device coordinates (-1 to +1) for both components
                const mouse = new THREE.Vector2(0, 0);
    
                // Update the raycaster with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);
    
                // Calculate the object intersecting the picking ray
                const intersection = raycaster.intersectObject(scene, true)[0]; // Retorna a primeira interseção encontrada
    
                if (intersection) {
                    const object = intersection.object;
    
                    const personagem = inimigos.find(inimigo => inimigo.mesh === object);
                    if (personagem) {
                        personagem.tomaDano(25);
                        municao -= 1;
                        console.log(municao);
                        showCrosshair();
                    }
                }
            }
        }
        
        let isShooting = false;
        let shootingInterval;
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mouseup', onMouseUp, false);

        function onMouseDown(event) {
            isShooting = true;
            startShooting();
        }

        function onMouseUp(event) {
            isShooting = false;
            stopShooting();
        }

        function startShooting() {
            if (shootingInterval) return; // Evitar múltiplos intervalos

            shootingInterval = setInterval(() => {
                if (isShooting) {
                    atira();
                }
            }, 100); // Ajuste o intervalo conforme necessário (100ms = 10 tiros por segundo)
        }

        function stopShooting() {
            clearInterval(shootingInterval);
            shootingInterval = null;
        }

        function criaKillLog(count) {
            // Crie uma nova div
            const kill_log = document.createElement('div');
            
            // Adicione conteúdo ou estilos à nova div, se necessário
            kill_log.id = 'killLog' + count;
            kill_log.display = 'block';
            kill_log.textContent = 'Você abateu o bot ' + count + "!";
            kill_log.style.backgroundColor = 'lightblue';
            kill_log.style.padding = '10px';
            kill_log.style.marginTop = '10px';
            kill_log.style.pointerEvents = 'none';
            kill_log.style.userSelect = 'none';
            // Adicione a nova div ao container existente no DOM
            const container = document.getElementById('killLogFrame');
            container.appendChild(kill_log);

        }

        function setKillLog(kill_log, tempo) {
            setTimeout(function() {
                kill_log.style.display = 'none';
            }, tempo);
        }

        // Add event listener for mouse click
        window.addEventListener('click', atira, false);
        
        const fpcam = new PointerLockControls( camera, renderer.domElement );

        scene.add(fpcam.getObject());
        
        const togglePointerLock = function () {
            if (document.pointerLockElement === renderer.domElement) {
                fpcam.unlock();
                menu.style.display = 'block';
            } else {
                fpcam.lock();
                menu.style.display = 'none';
            }
        };

        document.addEventListener('DOMContentLoaded', (event) => {
            const menu = document.getElementById('menu');
            
            menu.addEventListener('click', () => {
                togglePointerLock();
                isPointerLocked = !isPointerLocked;
            });
        });

        // Variável para rastrear o estado de bloqueio do mouse
        let isPointerLocked = false;

        // pausa
        document.addEventListener('keydown', function (event) {
            if (event.key === 'c' || event.key === 'C') {
                togglePointerLock();
                isPointerLocked = !isPointerLocked;
            }
        }, false);

        //Controles 

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const direction = new THREE.Vector3();
        let collisionDistance = 1;

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function detectCollisions() {
            camera.getWorldDirection(direction);
            raycaster.set(camera.position, direction);

            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0 && intersects[0].distance < 1) {
                // Se a câmera está muito perto do objeto, impede o movimento para frente
                // Move a câmera para trás
                camera.position.addScaledVector(direction, -0.1);
            }
        }

        const mouse = new THREE.Vector2();
        let count = 0;

        const person = new FirstPersonControls(camera, renderer.domElement);
        person.movementSpeed = 5;
        person.lookSpeed = 0.8;
        person.noFly = true;
        person.lookVertical = true;

        let clock = new THREE.Clock(true);

        camera.position.set(0, 1.7, 0);
        let cameraHeight = camera.position.y;

        chao.rotation.x = -Math.PI/2;
        scene.add( chao );

        geraInimigos(7);

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;

        const keyboard = new THREEx.KeyboardState();

        function animate() {
            requestAnimationFrame( animate );
            const delta = clock.getDelta();

            if (moveForward) camera.translateZ(-person.movementSpeed * delta);
            if (moveBackward) camera.translateZ(person.movementSpeed * delta);
            if (moveLeft) camera.translateX(-person.movementSpeed * delta);
            if (moveRight) camera.translateX(person.movementSpeed * delta);

            camera.position.y = cameraHeight;
            detectCollisions();
            renderer.render( scene, camera );
        }
        
        function handleKeydown(event) {
            if (keyboard.pressed("w")) moveForward = true;
            if (keyboard.pressed("s")) moveBackward = true;
            if (keyboard.pressed("a")) moveLeft = true;
            if (keyboard.pressed("d")) moveRight = true;
            if (keyboard.pressed("shift+w")) person.movementSpeed = 9;
            if (keyboard.pressed("v")) cameraHeight = 1;
            if (keyboard.pressed("r")){
                document.getElementById('recarga').textContent = "Recarregando...";
                setTimeout(() => {
                    municao = 15;
                    document.getElementById('recarga').textContent = municao;
                }, 1500);}; 
            if (keyboard.pressed("t")) geraInimigos(7);
            
            /*
            if (keyboard.pressed("space")){
                if (cameraHeight <= 3) { 
                    cameraHeight += 2; 
                } else {
                    if (cameraHeight > 1.7) {
                        cameraHeight = 1.7; 
                    }
                }
            }
            */
        }

        function handleKeyup(event) {
            if (!keyboard.pressed("w")) moveForward = false;
            if (!keyboard.pressed("s")) moveBackward = false;
            if (!keyboard.pressed("a")) moveLeft = false;
            if (!keyboard.pressed("d")) moveRight = false;
            if (!keyboard.pressed("shift+w")) person.movementSpeed = 5;
            if (!keyboard.pressed("v")) cameraHeight = 1.7;
            if(!KeyboardState.pressed("r")) 
                document.getElementById('recarga').textContent = municao;
        }

        // Adiciona event listeners para o teclado
        document.addEventListener('keydown', handleKeydown);
        document.addEventListener('keyup', handleKeyup);
        animate();



    </script>

</body>
</html>